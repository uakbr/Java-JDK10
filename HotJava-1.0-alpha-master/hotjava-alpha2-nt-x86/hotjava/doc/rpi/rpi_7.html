<!-- Generated with CERN WebMaker 1.4 -->
<HTML>
<HEAD>
<TITLE>Implementing Native Methods: Generating C Stubs</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING11></A>
<A HREF="rpi_1.html">Contents</A> <A HREF="rpi_6.html">Prev</A> <A HREF="rpi_8.html">Next</A><P>
<H1>5  Generating C Stubs</H1>
<HR>
<DL>
<DT><A HREF="rpi_7.html#HEADING12"><B> 5.1 </B> - Stub File for the InputFile Class</A><DD>
<DT><A HREF="rpi_7.html#HEADING13"><B> 5.2 </B> - Stub File for OutputFile Class</A><DD>
<DT><A HREF="rpi_7.html#HEADING14"><B> 5.3 </B> - Method Signatures</A><DD>
</DL>


Since the Java interpreter needs to marshal parameters between Java structures and C structures, a C stub interface is placed between the Java methods and the native C implementation. As with generating the C headerfiles, we use javah on a previously compiled class file to generate the stubs file. The stubs file is generated using the -stubs options to javah.<P>
In actual practice, there isn't much you need to know about stub files other than knowing they need to be part of your dynamically linked library. They are used as the well known interface between Java method invocations by the interpreter to marshal parameters between Java and a C library.<P>
Stub generation produces a noteworthy artifact. Method signatures are generated by javah -stubs. Method signatures are significant, because C functions use these signature strings to execute Java methods from within the C function (in effect calling back into Java code). See "<A HREF="#1">Method Signatures</A>" for more information.<P>
<A NAME=HEADING12></A>
<HR>
<H3>Stub File for the InputFile Class</H3>
<P>
<PRE>
/* Stubs for class demo/InputFile */
/* DO NOT EDIT THIS FILE - it is machine generated */

/* SYMBOL: "demo/InputFile/open()Z", demo_InputFile_open_stub, */
stack_item *demo_InputFile_open_stub(stack_item *_P_,
                                      struct execenv *_EE_) {
		extern long demo_InputFile_open(void *);
		_P_[0].i = demo_InputFile_open(_P_[0].p);
		return _P_ + 1;
}
/* SYMBOL: "demo/InputFile/close()V", demo_InputFile_close_stub, */
stack_item *demo_InputFile_close_stub(stack_item *_P_,
                                      struct execenv *_EE_) {
		extern void demo_InputFile_close(void *);
		(void) demo_InputFile_close(_P_[0].p);
		return _P_;
}
/* SYMBOL: "demo/InputFile/read([BI)I", demo_InputFile_read_stub, */
stack_item *demo_InputFile_read_stub(stack_item *_P_,
                                      struct execenv *_EE_) {
		extern long demo_InputFile_read(void *,void *,long);
		_P_[0].i = demo_InputFile_read(_P_[0].p,((_P_[1].p)),
                                                           ((_P_[2]. i)));
		return _P_ + 1;
}
</PRE>
<A NAME=HEADING13></A>
<HR>
<H3>Stub File for OutputFile Class</H3>
<P>
<PRE>
/* Stubs for class demo/OutputFile */
/* DO NOT EDIT THIS FILE - it is machine generated */

/* SYMBOL: "demo/OutputFile/open()Z", demo_OutputFile_open_stub, */
stack_item *demo_OutputFile_open_stub(stack_item *_P_,
                                      struct execenv *_EE_) {
	 	extern long demo_OutputFile_open(void *);
		 _P_[0].i = demo_OutputFile_open(_P_[0].p);
		return _P_ + 1;
}
/* SYMBOL: "demo/OutputFile/close()V", demo_OutputFile_close_stub, */
stack_item *demo_OutputFile_close_stub(stack_item *_P_,
                                       struct execenv *_EE_) {
		extern void demo_OutputFile_close(void *);
		(void) demo_OutputFile_close(_P_[0].p);
		return _P_;
}
/* SYMBOL: "demo/OutputFile/write([BI)I", demo_OutputFile_write_stub, */
stack_item *demo_OutputFile_write_stub(stack_item *_P_,
                                       struct execenv *_EE_) {
		extern long demo_OutputFile_write(void *,void *,long);
		_P_[0].i = demo_OutputFile_write(_P_[0].p,((_P_[1].p)), 
                                                             ((_P_[2].i)));
		return _P_ + 1;
}
</PRE>
<A NAME=HEADING14></A>
<HR>
<H3><A NAME=1>Method Signatures</H3>
C functions which invoke Java methods do so using a method signature which indicates the method's name, the number and types of its arguments, and its return value.<P>
For example, from class Demo the close method has the following signature:<P>
<PRE>
Demo/close()V
</PRE>
In the above example, simple as it is, the method signature indicates that close is a function with no parameters and has a void return type. For detailed information on method signatures, please refer to the Java virtual machine specification.<P>
In a type signature, type names are:<P>
 I = integer<P>
 B = byte<P>
 C = char<P>
 L = classname, in the form:   Lclassname;<P>
 E = enum<P>
 F = float<P>
 S = unsigned short<P>
 Z = boolean<P>
 V = void<P>
So, as a second example,<P>
<PRE>
&lt;init&gt;(II)Lfp/gui/MouseEvent;
</PRE>
describes a method "&lt;init&gt;" which is a function that takes two integers as an argument and returns an instance of class fp/gui/MouseEvent ("&lt;init&gt;" is the "method name" of a constructor.)<P>
<A HREF="rpi_1.html">Contents</A> <A HREF="rpi_6.html">Prev</A> <A HREF="rpi_8.html">Next</A><P>
<B>Implementing Native Methods</B><P>
Generated with <A HREF="AboutWebMaker.html">CERN WebMaker</A>
</BODY>
</HTML>
